\chapter{\IfLanguageName{dutch}{Stand van zaken}{State of the art}}%
\label{ch:stand-van-zaken}

% Tip: Begin elk hoofdstuk met een paragraaf inleiding die beschrijft hoe
% dit hoofdstuk past binnen het geheel van de bachelorproef. Geef in het
% bijzonder aan wat de link is met het vorige en volgende hoofdstuk.

% Pas na deze inleidende paragraaf komt de eerste sectiehoofding.

Dit hoofdstuk bevat je literatuurstudie. De inhoud gaat verder op de inleiding, maar zal het onderwerp van de bachelorproef *diepgaand* uitspitten. De bedoeling is dat de lezer na lezing van dit hoofdstuk helemaal op de hoogte is van de huidige stand van zaken (state-of-the-art) in het onderzoeksdomein. Iemand die niet vertrouwd is met het onderwerp, weet nu voldoende om de rest van het verhaal te kunnen volgen, zonder dat die er nog andere informatie moet over opzoeken \autocite{Pollefliet2011}.

Je verwijst bij elke bewering die je doet, vakterm die je introduceert, enz.\ naar je bronnen. In \LaTeX{} kan dat met het commando \texttt{$\backslash${textcite\{\}}} of \texttt{$\backslash${autocite\{\}}}. Als argument van het commando geef je de ``sleutel'' van een ``record'' in een bibliografische databank in het Bib\LaTeX{}-formaat (een tekstbestand). Als je expliciet naar de auteur verwijst in de zin, gebruik je \texttt{$\backslash${}textcite\{\}}.
Soms wil je de auteur niet expliciet vernoemen, dan gebruik je \texttt{$\backslash${}autocite\{\}}. In de volgende paragraaf een voorbeeld van elk.

\section{\IfLanguageName{dutch}{GraphQL}{GraphQL}}%
\label{sec:GraphQL}
Deze sectie van de literatuurstudie zal zich toespitsen op GraphQL en de belangrijke begrippen hieromtrent. Zo kan er vorm worden gegeven aan de probleemstelling die opgelost dient te worden. Via deze weg zal de context rondom GraphQL en de opvolgende deelvragen een duidelijk beeld scheppen betreffende deze technologie.

In dit deel spitsen we ons toe op de eerste deelvraag van dit onderzoek: “Wat is GraphQL?”
De hier opvolgende secties zijn opgesteld naarmate de benodigde onderdelen die helpen een beter beeld te scheppen over de werking van GraphQL en hoe deze software tot stand is gekomen. Van uit de probleemstelling wordt er vertrokken om dan doorheen deze studie tot een oplossing te komen, namelijk een werkende implementatie gebruikmakend van de Data Accelerator.
Dit wordt gevolgd door toelichting van de Data Accelerator. Hierin zal de werking en toepassing van de software binnen een werkomgeving in kaart gebracht worden, zodanig dat met begrip van voorgaande secties deze ook op niet mis te verstane wijze in beeld gebracht kan worden.

Het volgende deel zal dan de mogelijke voordelen bespreken van GraphQL en deze koppelen aan de Data Accelerator. Hiervoor zal er gekeken worden naar reeds bestaande onderzoeken die gelijkaardige materie duiding geven.
Tot slot zal er binnen de literatuurstudie besproken worden welke mogelijke integratie opties er zijn binnen de Data Accelerator en een synopsis van desbetreffende mogelijkheden.

\subsection{\IfLanguageName{dutch}{Gegevens ophalen}{Fetching data}}%
\label{sec:Gegevens ophalen}
In 2012 creëerde Facebook GraphQL omdat men binnen het bedrijf op zoek was naar een betere manier om data op te halen. Deze moest toepasbaar zijn over de hele lijn van producten en diensten waarover het bedrijf beschikte. De software zelf moest op zijn beurt verstaanbaar zijn voor zowel de ontwikkelaars, ontwerpers evenals collega’s die niet over technisch voorkennis beschikten. Na enkele jaren intern te hanteren is deze software publiek gesteld in 2015. Facebook hun doel van de software was een makkelijkere manier ontwikkelen om benodigde data op te halen zonder dat hun applicatie ontwikkelaars weten welke bronnen er exact gehanteerd werden. GraphQL kan om kort te gaan, gezien worden als een querytaal met een server gebaseerde runtime.

\subsection{\IfLanguageName{dutch}{Querytaal}{Query language}}%
\label{sec:Querytaal}
Een querytaal is een manier van schrijven met als doel data of informatie uit één of meerdere tabellen van een databank te verkrijgen.
Dit gebeurd aan de hand van een verzoek, de query, die specifieert welke data uit de gebruikte databank benodigd is. Die query bestaat uit een vastgelegde werkwijze van coderen zodat de databank het verzoek begrijpt en kan verwerken. In de meeste instanties bestaat een databank uit verschillende rijen en tabellen bevattende data omtrent een speciefiek thema zoals gegevens van werknemers. Via een query kan je de tabel met gegevens aanspreken om de gewenste data op te vragen, aan te passen, sorteren en uiteindelijk weergeven aan de gebruiker naar gelang de gebruikte commandos in het verzoek.

\subsection{\IfLanguageName{dutch}{Runtime}{Runtime}}%
\label{sec:Runtime}
Runtime kan beschreven worden als de looptijd van een programma. Dit begint bij het opstarten tot en met het afsluiten hiervan en is op zijn beurt een belangrijk process binnen het programmeren. De runtime maakt bij dit proces gebruik van verscheidene externe instructies om een foutloze uitvoering te bekomen. Onder deze voorheen vernoemde instructies vallen runtime omgevingen behorende tot de gebruikte programmeertaal. Om kort verder duiding te geven kunnen we runtime omgevingen beschrijven als een laag werkende bovenop het besturingssysteem die andere programmas omvat om zo de benodigde taken bij te houden en instructies te geven om ons programma draaiende te krijgen. Deze zet dan ook de gebruikte programmeertaal om naar machine code, binaire of hexadecimale instructies die rechtstreeks gebruikt kunnen worden door een processor.

\subsection{\IfLanguageName{dutch}{Graaf}{Graph}}%
\label{sec:graaf}
Een graaf kan gezien worden als een groep punten benoemd als knopen en hun onderlinge verbindingen, genaamd bogen. Een verbinding kan ook een pijl bevatten om zijn richting aan te tonen. Op deze manier kunnen de relaties tussen verscheidene knopen in beeld gebracht worden. In het werkstuk van \textcite{Brysbaert2021} wordt dit voorgesteld als een schema waarbij de knopen gebruikers zijn van het sociale media platform facebook en bogen de onderlinge vriendschap voorstellen. De bogen bevatten ook een pijl naar beide richtingen, omdat een vriendschap op het platform een wederzijdse toepassing is. Dit is niet altijd een vereiste.

Als we het voorbeeld van youtube gebruiken, kunnen we vaststellen dat het mogelijk is je te aboneren op een kanaal van een persoon. Dit wilt niet zeggen dat deze in kwestie daarom ook geabonneerd is op jouw kanaal. In dat geval zou de pijl dan een enkele richting hebben.

De hierboven uitgelegde werking kan men ook toepassen op een bestaande databank. Er zijn verbindingen tussen verschillende soorten data die elk ook hun specieke kenmerken bevatten. Via GraphQL kan men dus hierop inspelen en dichter op de actuele werking van een databank te werk gaan.

(figuur gebruikersFacebook)

\subsection{\IfLanguageName{dutch}{Gebruik}{Usage}}%
\label{sec:Gebruik}
Bij de sterke punten van GraphQL hoort toch wel de preventie van over- en underfetching. Overfetching is een probleem die zich vaak voordoet bij eerder traditionele programmas, waarbij er te veel data opgevraagd wordt ten opzichte van wat benodigd is. Gebruikmakend van GraphQL kan men zich toespitsen op juist de data die van toepassing is. Dit zorgt voor een lager verbuik van bandbreedte, dat voordelig is als men ook gebruikt maakt van mobiele aparaten zoals ook facebook doet. Het omgekeerde kan zich echter ook voor doen, bij underfetching wordt niet alle opgevraagde data weergeven in één keer. Dit kan voorgesteld worden als een boodschappenlijstje bij colruyt waarbij er voor elke productbeschrijving een aparte query zou moeten uitgevoerd worden. Dit is ook een probleem waar GraphQL op inspeeld.

Voor ontwikkelaars is het ook handig dat GraphQL declaratief is, op deze manier is de data makkelijker te hanteren en zijn de queries overzichtelijker. Men kan ook gebruik maken van nesting om gerelateerde data op te vragen en om de queries zelf consistent te houden gedurende het hele proces. Via deze werkwijze moeten er dan ook geen responses samengevoegd worden. GraphQL bezit ook schemas die kunnen dienen als een contract om front-end apps te ontwikkelen (dit gebeurd door de API verzoeken te simuleren). Het back-end team kan het contract dan later aanleveren met de nodige diensten. Binnen een graaf moeten de ontwerpers maar over een enkele endpoint beschikken om toegang te hebben tot de achterliggende data.

\subsection{\IfLanguageName{dutch}{API}{API}}%
\label{sec:API}